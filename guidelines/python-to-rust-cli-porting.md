---
title: Python-to-Rust CLI Porting
description: CLI-specific patterns for porting Python CLI applications to Rust, including argparse-to-clap mapping and cross-validation
---
# Python-to-Rust CLI Porting

CLI-specific rules and patterns for porting Python command-line applications to Rust.
Covers argument parsing migration, cross-validation methodology, and acceptance criteria
for CLI parity.

For general porting rules, see `tbd guidelines python-to-rust-porting-rules`.
For Rust CLI patterns, see `tbd guidelines rust-cli-app-patterns`.
For Python CLI patterns, see `tbd guidelines python-cli-patterns`.

## CLI Argument Mapping

### argparse to clap

| Python argparse | Rust clap (derive) | Notes |
| --- | --- | --- |
| `add_argument("file")` | `#[arg(value_name = "FILE")] file: Option<PathBuf>` | Positional arg |
| `add_argument("-w", "--width")` | `#[arg(short = 'w', long)]` | Short + long flag |
| `add_argument("--flag", action="store_true")` | `#[arg(long)] flag: bool` | Boolean flag |
| `default=80` | `#[arg(default_value_t = 80)]` | Default value |
| `type=int` | `width: usize` | Type validation |
| `choices=["a","b"]` | `#[arg(value_enum)]` with enum | Enum validation |
| `nargs="+"` | `files: Vec<PathBuf>` | Multiple values |
| `help="description"` | `/// description` (doc comment) | Help text |

### typer/click to clap

| Python typer/click | Rust clap (derive) | Notes |
| --- | --- | --- |
| `@app.command()` | `#[derive(Parser)]` | Command definition |
| `typer.Argument()` | `#[arg()]` on positional | Positional |
| `typer.Option()` | `#[arg(long)]` | Named option |
| `callback=...` | Implement in `main()` | |

### Exact Flag Parity Requirements

The Rust CLI MUST match the Python CLI exactly:
- Same flag names (long and short)
- Same default values
- Same help text (word-for-word when possible)
- Same behavior when flags are combined

Validation approach:
```bash
python -m project --help > python-help.txt
cargo run -- --help > rust-help.txt
diff python-help.txt rust-help.txt  # Must show zero meaningful diffs
```

## I/O Parity

### Stdin/Stdout Behavior

The Rust CLI must handle I/O exactly like Python:
```bash
# File input, stdout output
python -m project input.md    # Python
project input.md              # Rust -- same output

# Stdin input, stdout output
cat input.md | python -m project    # Python
cat input.md | project              # Rust -- same output

# File input, file output
python -m project input.md -o output.md
project input.md -o output.md
diff <(cat output_py.md) <(cat output_rs.md)  # Zero diffs
```

### Error Message Parity

Error messages should match Python's format or be clearly improved:
```
# Python: "error: file not found: missing.md"
# Rust:   "error: file not found: missing.md"  (exact match preferred)
```

All error messages go to stderr. All program output goes to stdout.

### Exit Code Parity

| Condition | Python | Rust | Notes |
| --- | --- | --- | --- |
| Success | 0 | 0 | |
| General error | 1 | 1 | |
| Usage error | 2 | 2 | clap returns 2 automatically |
| SIGINT | 130 | 130 | Register ctrlc handler |

## Cross-Validation Methodology

Cross-validation is the most important quality gate for a port. It runs both
implementations against the same inputs and diffs the outputs.

### Setup

1. **Python source as submodule:**
   ```bash
   git submodule add https://github.com/org/project-python.git python-repo
   ```

2. **Shared test fixtures:**
   ```
   test-fixtures/
   ├── input/          # Input files
   │   ├── basic.md
   │   ├── complex.md
   │   └── edge-cases.md
   └── expected/       # Expected outputs (generated by Python)
       ├── basic.md
       ├── complex.md
       └── edge-cases.md
   ```

3. **Cross-validation script** (`scripts/cross-validate.sh`):
   ```bash
   #!/usr/bin/env bash
   set -euo pipefail

   cargo build --release
   RUST_BIN="target/release/project"
   PY_CMD=(uv run -q --project python-repo python -m project)

   PASSED=0; FAILED=0
   for input in test-fixtures/input/*.md; do
       name="$(basename "$input")"
       py_out=$(mktemp); rs_out=$(mktemp)

       "${PY_CMD[@]}" "$input" > "$py_out"
       "$RUST_BIN" "$input" > "$rs_out"

       if diff -q "$py_out" "$rs_out" >/dev/null; then
           echo "PASS: $name"
           PASSED=$((PASSED + 1))
       else
           echo "FAIL: $name"
           diff -u "$py_out" "$rs_out" | head -20
           FAILED=$((FAILED + 1))
       fi
       rm -f "$py_out" "$rs_out"
   done

   echo "Results: $PASSED passed, $FAILED failed"
   [ "$FAILED" -eq 0 ]
   ```

### Running Cross-Validation

1. Ensure Python environment is set up: `cd python-repo && uv sync`
2. Build Rust: `cargo build --release`
3. Run: `./scripts/cross-validate.sh`
4. Investigate any diffs -- they reveal parser/behavioral differences

### Interpreting Differences

When cross-validation finds diffs:

1. **Categorize the difference:**
   - Parser behavior (different library, not a code bug)
   - Porting bug (code error, fix immediately)
   - Python bug (found a bug in the original -- coordinate with Python repo)
   - Intentional improvement (Rust behavior is better -- document and accept)

2. **For parser differences:**
   - Can it be worked around with post-processing? (preferred)
   - Is it an edge case that rarely occurs? (accept and document)
   - Is it a core behavior difference? (consider switching libraries)

3. **Document everything** in `cross-validation-assessment.md`

## Version Tracking Between Repos

### Build-Time Version Extraction

Use `build.rs` to extract the Python version from the submodule:
```rust
fn main() {
    // Try git describe on the submodule
    let version = std::process::Command::new("git")
        .args(["describe", "--tags", "--always"])
        .current_dir("python-repo")
        .output()
        .ok()
        .and_then(|o| String::from_utf8(o.stdout).ok())
        .unwrap_or_else(|| "unknown".into());

    println!("cargo:rustc-env=PYTHON_SOURCE_VERSION={}", version.trim());
}
```

### Version Display

```
$ project --version
project 0.1.0 (port of python-project 0.5.5)
```

### Version Correspondence Table

Maintain in `docs/version-history.md`:
```markdown
| Rust Version | Python Version | Date       | Notes         |
|--------------|----------------|------------|---------------|
| 0.1.0        | v0.5.5         | 2024-11-02 | Initial port  |
| 0.1.1        | v0.5.6         | 2024-11-15 | Bug fixes     |
```

## Handling Python Bugs Found During Porting

The porting process often discovers bugs in the original Python code. Strategy:

1. **Confirm it's a bug** -- not a feature or intentional behavior difference
2. **File a bug/PR** on the Python repo with a test case
3. **Decide whether to replicate the bug** in Rust for parity or fix it
4. **If fixing:** document the intentional divergence from Python
5. **If replicating:** add a `XXX: Python bug` comment and track for future cleanup

## Ongoing Synchronization

When the Python repo gets updates:

1. Update the submodule: `cd python-repo && git pull origin main`
2. Categorize changes: bug fixes, new features, test additions, refactoring
3. Port relevant changes to Rust
4. Run cross-validation to verify parity is maintained
5. Update version correspondence table
6. Document in sync log

## Acceptance Criteria for CLI Parity

**All of these must pass before the port is considered complete:**

- [ ] `--help` output matches Python (format may differ slightly due to clap)
- [ ] `--version` shows both Rust and Python versions
- [ ] All Python CLI flags have Rust equivalents with same names and defaults
- [ ] Stdin/stdout behavior is identical
- [ ] Exit codes match for all error conditions
- [ ] Cross-validation passes with zero diffs on all test fixtures
- [ ] Error messages go to stderr, output to stdout
- [ ] Performance is at least 10x faster than Python (typical for Rust CLI)
- [ ] Binary size < 10MB (stripped release build)
- [ ] Startup time < 50ms

## Related Guidelines

- For general porting rules, see `tbd guidelines python-to-rust-porting-rules`
- For Rust CLI patterns, see `tbd guidelines rust-cli-app-patterns`
- For Python CLI patterns, see `tbd guidelines python-cli-patterns`
- For test coverage, see `tbd guidelines test-coverage-for-porting`
- For golden testing, see `tbd guidelines golden-testing-guidelines`
